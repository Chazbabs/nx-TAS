/* This Bison file was machine-generated by BNFC */
%{
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
#include "Absyn.H"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
int yyparse(void);
int yylex(void);
YY_BUFFER_STATE TasScriptyy_scan_string(const char *str);
void TasScriptyy_delete_buffer(YY_BUFFER_STATE buf);
int TasScriptyy_mylinenumber;
int TasScriptinitialize_lexer(FILE * inp);
int TasScriptyywrap(void)
{
  return 1;
}
void TasScriptyyerror(const char *str)
{
  extern char *yytext;
  fprintf(stderr,"error: line %d: %s at %s\n", 
    yy_mylinenumber, str, yytext);
}


namespace TasScript
{
static Prog* YY_RESULT_Prog_ = 0;
Prog* pProg(FILE *inp)
{
  TasScriptyy_mylinenumber = 1;
  TasScriptinitialize_lexer(inp);
  if (yyparse())
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return YY_RESULT_Prog_;
  }
}
Prog* pProg(const char *str)
{
  YY_BUFFER_STATE buf;
  int result;
  TasScriptyy_mylinenumber = 1;
  TasScriptinitialize_lexer(0);
  buf = TasScriptyy_scan_string(str);
  result = yyparse();
  TasScriptyy_delete_buffer(buf);
  if (result)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return YY_RESULT_Prog_;
  }
}

static ListLine* YY_RESULT_ListLine_ = 0;
ListLine* pListLine(FILE *inp)
{
  TasScriptyy_mylinenumber = 1;
  TasScriptinitialize_lexer(inp);
  if (yyparse())
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return YY_RESULT_ListLine_;
  }
}
ListLine* pListLine(const char *str)
{
  YY_BUFFER_STATE buf;
  int result;
  TasScriptyy_mylinenumber = 1;
  TasScriptinitialize_lexer(0);
  buf = TasScriptyy_scan_string(str);
  result = yyparse();
  TasScriptyy_delete_buffer(buf);
  if (result)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return YY_RESULT_ListLine_;
  }
}

static Line* YY_RESULT_Line_ = 0;
Line* pLine(FILE *inp)
{
  TasScriptyy_mylinenumber = 1;
  TasScriptinitialize_lexer(inp);
  if (yyparse())
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return YY_RESULT_Line_;
  }
}
Line* pLine(const char *str)
{
  YY_BUFFER_STATE buf;
  int result;
  TasScriptyy_mylinenumber = 1;
  TasScriptinitialize_lexer(0);
  buf = TasScriptyy_scan_string(str);
  result = yyparse();
  TasScriptyy_delete_buffer(buf);
  if (result)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return YY_RESULT_Line_;
  }
}

static Command* YY_RESULT_Command_ = 0;
Command* pCommand(FILE *inp)
{
  TasScriptyy_mylinenumber = 1;
  TasScriptinitialize_lexer(inp);
  if (yyparse())
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return YY_RESULT_Command_;
  }
}
Command* pCommand(const char *str)
{
  YY_BUFFER_STATE buf;
  int result;
  TasScriptyy_mylinenumber = 1;
  TasScriptinitialize_lexer(0);
  buf = TasScriptyy_scan_string(str);
  result = yyparse();
  TasScriptyy_delete_buffer(buf);
  if (result)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return YY_RESULT_Command_;
  }
}

static ControllerType* YY_RESULT_ControllerType_ = 0;
ControllerType* pControllerType(FILE *inp)
{
  TasScriptyy_mylinenumber = 1;
  TasScriptinitialize_lexer(inp);
  if (yyparse())
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return YY_RESULT_ControllerType_;
  }
}
ControllerType* pControllerType(const char *str)
{
  YY_BUFFER_STATE buf;
  int result;
  TasScriptyy_mylinenumber = 1;
  TasScriptinitialize_lexer(0);
  buf = TasScriptyy_scan_string(str);
  result = yyparse();
  TasScriptyy_delete_buffer(buf);
  if (result)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return YY_RESULT_ControllerType_;
  }
}


}
%}

%union
{
  int int_;
  char char_;
  double double_;
  char* string_;
  TasScript::Prog* prog_;
  TasScript::ListLine* listline_;
  TasScript::Line* line_;
  TasScript::Command* command_;
  TasScript::ControllerType* controllertype_;
}
%name-prefix="TasScriptyy"
%token _ERROR_
%token TASSCRIPT__SYMB_0    //   

%token TASSCRIPT__SYMB_1    //   
%token TASSCRIPT__SYMB_2    //   + 
%token TASSCRIPT__SYMB_3    //   - 
%token TASSCRIPT__SYMB_4    //   pro_controller

%type <prog_> Prog
%type <listline_> ListLine
%type <line_> Line
%type <command_> Command
%type <controllertype_> ControllerType

%start Prog
%token<string_> _IDENT_

%%
Prog : ListLine {  std::reverse($1->begin(),$1->end()) ;$$ = new TasScript::P($1); TasScript::YY_RESULT_Prog_= $$; } 
;
ListLine : /* empty */ {  $$ = new TasScript::ListLine(); TasScript::YY_RESULT_ListLine_= $$; } 
  | Line {  $$ = new TasScript::ListLine() ; $$->push_back($1); TasScript::YY_RESULT_ListLine_= $$; }
  | Line TASSCRIPT__SYMB_0 ListLine {  $3->push_back($1) ; $$ = $3 ; TasScript::YY_RESULT_ListLine_= $$; }
;
Line : TASSCRIPT__SYMB_1 {  $$ = new TasScript::LEmpty(); TasScript::YY_RESULT_Line_= $$; } 
  | Command {  $$ = new TasScript::LCommand($1); TasScript::YY_RESULT_Line_= $$; }
;
Command : TASSCRIPT__SYMB_2 _IDENT_ ControllerType {  $$ = new TasScript::CAddController($2, $3); TasScript::YY_RESULT_Command_= $$; } 
  | TASSCRIPT__SYMB_3 _IDENT_ {  $$ = new TasScript::CRemoveController($2); TasScript::YY_RESULT_Command_= $$; }
;
ControllerType : TASSCRIPT__SYMB_4 {  $$ = new TasScript::CTProController(); TasScript::YY_RESULT_ControllerType_= $$; } 
;

