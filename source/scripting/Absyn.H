#ifndef TASSCRIPT_ABSYN_HEADER
#define TASSCRIPT_ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.
namespace TasScript
{
/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Prog;
class Line;
class Command;
class ControllerType;
class P;
class LEmpty;
class LCommand;
class CAddController;
class CRemoveController;
class CTProController;
class ListLine;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProg(Prog *p) = 0;
  virtual void visitLine(Line *p) = 0;
  virtual void visitCommand(Command *p) = 0;
  virtual void visitControllerType(ControllerType *p) = 0;
  virtual void visitP(P *p) = 0;
  virtual void visitLEmpty(LEmpty *p) = 0;
  virtual void visitLCommand(LCommand *p) = 0;
  virtual void visitCAddController(CAddController *p) = 0;
  virtual void visitCRemoveController(CRemoveController *p) = 0;
  virtual void visitCTProController(CTProController *p) = 0;
  virtual void visitListLine(ListLine *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Prog : public Visitable
{
public:
  virtual Prog *clone() const = 0;

};

class Line : public Visitable
{
public:
  virtual Line *clone() const = 0;

};

class Command : public Visitable
{
public:
  virtual Command *clone() const = 0;

};

class ControllerType : public Visitable
{
public:
  virtual ControllerType *clone() const = 0;

};



class P : public Prog
{
public:
  ListLine *listline_;

  P(const P &);
  P &operator=(const P &);
  P(ListLine *p1);
  ~P();
  virtual void accept(Visitor *v);
  virtual P *clone() const;
  void swap(P &);
};

class LEmpty : public Line
{
public:

  LEmpty(const LEmpty &);
  LEmpty &operator=(const LEmpty &);
  LEmpty();
  ~LEmpty();
  virtual void accept(Visitor *v);
  virtual LEmpty *clone() const;
  void swap(LEmpty &);
};

class LCommand : public Line
{
public:
  Command *command_;

  LCommand(const LCommand &);
  LCommand &operator=(const LCommand &);
  LCommand(Command *p1);
  ~LCommand();
  virtual void accept(Visitor *v);
  virtual LCommand *clone() const;
  void swap(LCommand &);
};

class CAddController : public Command
{
public:
  Ident ident_;
  ControllerType *controllertype_;

  CAddController(const CAddController &);
  CAddController &operator=(const CAddController &);
  CAddController(Ident p1, ControllerType *p2);
  ~CAddController();
  virtual void accept(Visitor *v);
  virtual CAddController *clone() const;
  void swap(CAddController &);
};

class CRemoveController : public Command
{
public:
  Ident ident_;

  CRemoveController(const CRemoveController &);
  CRemoveController &operator=(const CRemoveController &);
  CRemoveController(Ident p1);
  ~CRemoveController();
  virtual void accept(Visitor *v);
  virtual CRemoveController *clone() const;
  void swap(CRemoveController &);
};

class CTProController : public ControllerType
{
public:

  CTProController(const CTProController &);
  CTProController &operator=(const CTProController &);
  CTProController();
  ~CTProController();
  virtual void accept(Visitor *v);
  virtual CTProController *clone() const;
  void swap(CTProController &);
};



class ListLine : public Visitable, public std::vector<Line*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLine *clone() const;
};


}
#endif
