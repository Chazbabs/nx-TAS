//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"
namespace TasScript
{
/********************   P    ********************/
P::P(ListLine *p1)
{
  listline_ = p1;

}

P::P(const P & other)
{
  listline_ = other.listline_->clone();

}

P &P::operator=(const P & other)
{
  P tmp(other);
  swap(tmp);
  return *this;
}

void P::swap(P & other)
{
  std::swap(listline_, other.listline_);

}

P::~P()
{
  delete(listline_);

}

void P::accept(Visitor *v)
{
  v->visitP(this);
}

P *P::clone() const
{
  return new P(*this);
}



/********************   LEmpty    ********************/
LEmpty::LEmpty()
{

}

LEmpty::LEmpty(const LEmpty & other)
{

}

LEmpty &LEmpty::operator=(const LEmpty & other)
{
  LEmpty tmp(other);
  swap(tmp);
  return *this;
}

void LEmpty::swap(LEmpty & other)
{

}

LEmpty::~LEmpty()
{

}

void LEmpty::accept(Visitor *v)
{
  v->visitLEmpty(this);
}

LEmpty *LEmpty::clone() const
{
  return new LEmpty(*this);
}



/********************   LCommand    ********************/
LCommand::LCommand(Command *p1)
{
  command_ = p1;

}

LCommand::LCommand(const LCommand & other)
{
  command_ = other.command_->clone();

}

LCommand &LCommand::operator=(const LCommand & other)
{
  LCommand tmp(other);
  swap(tmp);
  return *this;
}

void LCommand::swap(LCommand & other)
{
  std::swap(command_, other.command_);

}

LCommand::~LCommand()
{
  delete(command_);

}

void LCommand::accept(Visitor *v)
{
  v->visitLCommand(this);
}

LCommand *LCommand::clone() const
{
  return new LCommand(*this);
}



/********************   CAddController    ********************/
CAddController::CAddController(Ident p1, ControllerType *p2)
{
  ident_ = p1;
  controllertype_ = p2;

}

CAddController::CAddController(const CAddController & other)
{
  ident_ = other.ident_;
  controllertype_ = other.controllertype_->clone();

}

CAddController &CAddController::operator=(const CAddController & other)
{
  CAddController tmp(other);
  swap(tmp);
  return *this;
}

void CAddController::swap(CAddController & other)
{
  std::swap(ident_, other.ident_);
  std::swap(controllertype_, other.controllertype_);

}

CAddController::~CAddController()
{
  delete(controllertype_);

}

void CAddController::accept(Visitor *v)
{
  v->visitCAddController(this);
}

CAddController *CAddController::clone() const
{
  return new CAddController(*this);
}



/********************   CRemoveController    ********************/
CRemoveController::CRemoveController(Ident p1)
{
  ident_ = p1;

}

CRemoveController::CRemoveController(const CRemoveController & other)
{
  ident_ = other.ident_;

}

CRemoveController &CRemoveController::operator=(const CRemoveController & other)
{
  CRemoveController tmp(other);
  swap(tmp);
  return *this;
}

void CRemoveController::swap(CRemoveController & other)
{
  std::swap(ident_, other.ident_);

}

CRemoveController::~CRemoveController()
{

}

void CRemoveController::accept(Visitor *v)
{
  v->visitCRemoveController(this);
}

CRemoveController *CRemoveController::clone() const
{
  return new CRemoveController(*this);
}



/********************   CTProController    ********************/
CTProController::CTProController()
{

}

CTProController::CTProController(const CTProController & other)
{

}

CTProController &CTProController::operator=(const CTProController & other)
{
  CTProController tmp(other);
  swap(tmp);
  return *this;
}

void CTProController::swap(CTProController & other)
{

}

CTProController::~CTProController()
{

}

void CTProController::accept(Visitor *v)
{
  v->visitCTProController(this);
}

CTProController *CTProController::clone() const
{
  return new CTProController(*this);
}




/********************   ListLine    ********************/

void ListLine::accept(Visitor *v)
{
  v->visitListLine(this);
}


ListLine *ListLine::clone() const
{
  return new ListLine(*this);
}



}
